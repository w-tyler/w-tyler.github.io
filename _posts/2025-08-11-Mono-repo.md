---
layout: post
title: "Mono Repo 模式与 CI 实践"
date: 2025-08-11
categories: [DevOps, CI/CD]
tags: [monorepo, ci, devops, 软件架构]
---

## 引言

目前，软件架构逐渐从大泥球模式向微服务模式转变，这种情况下，Multi Repos逐渐成为了目前软件开发的标准模式——基于团队、服务或者领域等划分Repo，每个Repo都有自己的构建标准和构建流水线。这种模式有一个非常大的优势：团队自治，每个团队可以自主决定使用何种语言、使用何种技术架构、引用哪些第三方库、自主制定发布策略以及自主控制代码权限等等，并且由于每个repo的体量比较小，便于CICD的实施，开发快速且灵活。

这种模式看起来有很多优点，但我们如果在开发也难免有一些难以解决的缺点，例如：

- 各个项目组各自为政，风格和规范不统一
- 整个系统集中的部署测试相对复杂，跨项目沟通成本高
- 开发人员缺乏对整个系统架构和业务目标的理解
- 鼓励了孤立文化，各个项目会出现重复造轮子的情况，难以统一最佳实践，不利于团队共享的文化
- 项目之间的依赖管理、版本管理比较复杂等等

因此，Google等大厂开始推行Mono Repo的管理模式。

## Mono Repo是什么

Monorepo不是一种具体的技术，而是一种管理项目的概念，许多人会理解为把所有代码放在一个repo中，如果只是把代码简单地全部放在一个repo中，那只会更加的杂乱无章并且导致repo的体量更加庞大，开发管理更加困难。

以下有两个有关于Mono Repo的定义：

> A monorepo is a single repository containing multiple distinct projects, with well-defined relationships[1].

> In version control systems, a monorepo ("mono" meaning 'single' and "repo" being short for 'repository') is a software development strategy where code for many projects is stored in the same repository[2].

所以，Mono Repo不是简单把代码堆在一起，而是将边界清晰且有关联关系的不同项目按照一定的组织模式放在同一个repo中。

![Mono Repo 架构示意图](/assets/images/2025-08-11-mono-repo/2025-08-11-mono-repo-01.png)

## Mono Repo优势

目前很多公司已经开始使用Mono Repo模式来管理项目代码，例如Google, Meta, Microsoft, Uber, Airbnb, Facebook, babel, Twitter, Bilibili等。

Mono Repo可以带来但不仅限于以下优势：

- **代码重用和共享容易**：因为代码放在同一个repo中，我们可以非常轻松的抽取出公共的组件和工具，在不同项目中进行复用
- **依赖管理简单**：因为代码在同一个repo中，会非常容易追踪项目更改对其他项目的影响，通过一些工具可以更好的进行依赖管理
- **代码重构更加自信**：在Mono Repo中，可以明确看到代码重构的影响范围，也可以通过测试降低不确定性带来的对代码重构的恐惧，鼓励开发人员不断优化代码
- **代码规范容易管理**：在同一个repo中，更容易制定统一的代码规范，集中开展code review
- **共享系统总体视图**：团队成员可以看到整个系统的代码，更容易获取到整个系统的总体视图以及对齐业务目标
- **开放透明共享的文化**：团队每个成员都可以去查看以及修改其他人的代码，团队成员会对自己的代码更加负责，会形成一种良好的技术氛围，有助于团队代码质量提升

而说到实际落地的效果，从B站后端切换过程的经验来看，Mono Repo很好解决了团队关于版本管理、依赖管理、代码质量方面的痛点，带来的问题主要是切换初期一些管理规范、大量新工具链的引入、CICD以及团队成员代码能力的挑战[3]，总的来说项目成熟后带来的优势还是比较明显的。

Google曾经发表过一篇论文来介绍如何将数十亿代码通过monrepo的方式组织起来[4]，关于效果的总结如下：

> Benefits include unified versioning, extensive code sharing, simplified dependency management, atomic changes, large-scale refactoring, collaboration across teams, flexible code ownership, and code visibility.
> 
> Drawbacks include having to create and scale tools for development and execution and maintain code health, as well as potential for codebase complexity (such as unnecessary dependencies).

## Mono Repo痛点

### CI复杂度变高

在Mutli Repo的模式下，pipeline一般是服务独享，每个项目团队只需要关心自己所负责的项目的构建过程或者说是最终制品即可，整个构建过程可以灵活的进行自定义，CI的搭建过程简单。而Mono repo的CI包含了所有项目的构建过程，构建任务在同一条流水线中完成，pipeline的复杂度高，需要制定更佳完备的项目规范以及发布策略，项目前期极易出现混乱。

### 构建时间长

如果某个commit影响的服务较多或者修改了公共组件库的代码，那么需要重新构建的服务可能会非常的多，单次构建的时间可能会变得非常长，因为流水线只有一条并且难以并行，可能会在一段时间内block之后的commit。

### 对目录结构和依赖规范要求较高

Mono Repo体量较大，需要前期制定良好的目录结构规范和依赖管理规范，否则会导致项目结构的混乱。

### 无法细粒度权限管理

所有服务都在同一个Repo，无法实施项目级粒度权限管理，如果出现泄露问题会泄露所有代码。

### 性能问题

repo体量变大，git clone、切换分支等git操作速度会变慢，初始化依赖速度非常慢，也会导致CI运行的速度变慢。

## 项目整体介绍

本项目为云迁移项目，将已有的产品迁移到国内云厂商，整个项目现行的发布流程基本如下图所示：

![项目发布流程图](/assets/images/2025-08-11-mono-repo/2025-08-11-mono-repo-02.png)

本项目简化文件结构如下：

![项目文件结构图](/assets/images/2025-08-11-mono-repo/2025-08-11-mono-repo-03.png)

- `pkg`下存放有公共包和工具
- `apps`存放前端项目
- `services`下存放后端项目
- `infrastructure`存放基础设置的定义
- `tests`下存放测试相关内容
- `Jenkinsfile`定义了流水线的执行过程
- `Makefile`定义了统一的make命令入口和判断逻辑

## 项目CI部分介绍

现阶段项目的CI已经初步搭建完成并且稳定运行中，目前包含了以下几个阶段：

- **Pre Build**：主要作用为判断本次运行需要构建哪些服务以及进行一些构建前的必要准备
- **Build Services**：对需要构建的后端服务运行lint、unit test、build以及package 
- **Build Apps**：对需要构建的前端服务运行lint、unit test、build以及package 
- **Generate Manifest Files**：对所需构建的前后端服务生成manifest files并上传到指定位置
- **Notification**：CI失败后发送通知到指定teams channel并艾特相关小伙伴

未来还需要引入的内容:
- 集成测试
- 除前后端服务以外其他内容的自动化

### Pre Build Stage

Mutli Repo模式下，每个repo对应的流水线被触发后，可能的情况是直接根据最新代码进行构建，最终生成制成品即可。但是Mono Repo模式下，直接对所有的服务进行构建是不现实的，所以至少要有判断需要构建哪些服务的步骤。

本项目采用的方法是从Jenkins构建历史中找到最近构建成功的一次，获取到commitId，使用git diff命令得到本次commit和上次成功构建的commit之间差异文件列表（对比上次成功的构建可以包容某次job意外失败的情况），根据相对应的规则判断出需要构建哪些服务。我们要求每个服务都需要有一个yaml格式的Buildfile作为CI的内容输入，其中就包含dependsOn，里面列出了这个服务所有的依赖项，当依赖项发生改变时，那么这个服务就需要执行构建了。

### Build Stage

Mono Repo里面存放着那么多的服务，如果某次提交修改了公共组件，所有服务同时构建，构建时间会非常长，使用parallel命令并行构建，并且我们要求Builfile中要提供groupName，我们会依此进行分组构建，一方面可以通过group数量保证不会同时启动大量job，另一方面也可以通过分组避免了一些冲突的情况。

Mono Repo下服务众多，不同服务的构建过程可能不同，不可能给每个服务定义构建过程，所以我们使用Makefile定义了公共的构建过程的命令，每个服务也会有自己的Makefile，可以在自身的Makefile中覆写构建过程，因此CI中只需要执行标准命令即可，兼容了标准化和客制化。

Mono Repo包含了很多项目的多个构建阶段，需要的环境可能有所不同，由于Jenkins支持多agents，所以可以利用不同的base image启动不同的构建环境，我们要求Buildfile中包含builder，表明需要的agent，在CI构建过程中就可以使用指定agent进行构建，每个agent对应一种构建环境。

### Generate Manifest Files Stage

这部分比较简单，manifest file都已经抽成了标准模板，我们要求服务针对每个环境添加对应的ovelays即可，其中的变量均可从环境变量获取，CI过程中会生成大量的环境变量以供生成manifest file使用。

### Notification Stage

很多项目都有CI看板，CI的健康情况可以直接通过看板来监测，当某条流水线breakdown的时候，能第一时间发现并修复。但是当大家都是远程办公的情况下，可能没有专门的设备来做看板，这时候就需要CI的Notification了。

Jenkins有发送邮件的插件，但是邮件经常会被淹没在999+中，容易被忽略，所以选择了项目使用的Teams来实现notification。

Teams、Slack这类工具都有channel的webhook功能，简单来说就是会暴露一个URL，指向具体的channel，通过向这个URL发POST请求可以将信息直接发到指定的channel。

在Jenkins pipeline的post阶段可以在pipeline job失败的情况下向Webhook URL发送post请求并带上自定义的数据用来通知CI失败情况。进一步，可以通过Jenkins的环境变量拿到提交者的邮箱，在该邮箱与Teams邮箱一致的情况下，可以利用Teams提供的新功能直接在Channel里面艾特对应的小伙伴，实现实时精准打击，避免长时间block其他小伙伴的构建。

## 总结

本文简单介绍了Mono Repo模式以及基于该模式的CI实践的一些内容。

Mono Repo不是银弹，只是提供的一种管理模式的参考，该采用什么模式还是要具体项目具体分析，合适的就是最好的。Mono Repo使得CI复杂度提高，需要合理有效的项目管理规范才能让CI可以更加有效的运行，发挥应有的作用。

---

### 参考文献

[1] [Monorepo definition](https://monorepo.tools/)  
[2] [Wikipedia - Monorepo](https://en.wikipedia.org/wiki/Monorepo)  
[3] [B站后端Monorepo实践](https://example.com)  
[4] [Why Google Stores Billions of Lines of Code in a Single Repository](https://research.google/pubs/pub45424/)